{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mengukur Jarak Atribut Binary Mengukur Jarak Tipe categorical Overlay Metric Ketika semua atribut adalah bertipe nominal, ukuran jarak yang paling sederhana adalah dengan Ovelay Metric (OM) yang dinyatakan dengan d(x,y)=n\u2211i=1\u03b4(ai(x),ai(y))d(x,y)=\u2211i=1n\u03b4(ai(x),ai(y)) dimana nn adalah banyaknya atribut, ai(x)ai(x) dan ai(y)ai(y) adalah nilai atribut ke ii yaitu AiAi dari masing masing objek xx dan yy, \u03b4 (ai(x),ai(y))\u03b4 (ai(x),ai(y)) adalah 0 jika ai(x)=ai(y)ai(x)=ai(y) dan 1 jika sebaliknya. OM banyak digunakan oleh instance-based learning dan locally weighted learning. Jelas sekali , ini sedikit beruk untuk mengukur jarak antara masing-masing pasangan sample, karena gagal memanfaatkan tambahan informasi yang diberikan oleh nilai atribut nominal yang bisa membantu dalam generalisasi. Value Difference Metric (VDM) VDM dikenalkan oleh Standfill and Waltz, versi sederhana dari VDM tanpa skema pembobotan didefinsisikan dengan d(x,y)=n\u2211i=1C\u2211c=1|P(c|ai(x))\u2212P(c|ai(y))|d(x,y)=\u2211i=1n\u2211c=1C|P(c|ai(x))\u2212P(c|ai(y))| dimana CCadalah banyaknya kelas, P(c|ai(x))P(c|ai(x)) adalah probabilitas bersyarat dimana kelas xx adalah cc dari atribut AiAi, yang memiliki nilai ai(x)ai(x), P(c|ai(y))P(c|ai(y)) adalah probabilitas bersyarat dimana kelas yy adalah cc dengan atribut AiAi memiliki nilai ai(y)ai(y) VDM mengasumsikan bahwa dua nilai dari atribut adalah lebih dekat jika memiliki klasifikasi sama. Pendekatan lain berbasi probabilitas adalah SFM (Short and Fukunaga Metric) yang kemudian dikembangkan oleh Myles dan Hand dan didefinisikan dengan d(x,y)=C\u2211c=1|P(c|x)\u2212P(c|y)|d(x,y)=\u2211c=1C|P(c|x)\u2212P(c|y)| diman probabilitas keanggotaan kelas diestimasi dengan P(c|x)P(c|x) dan P(c|y)P(c|y) didekati dengan Naive Bayes, Minimum Risk Metric (MRM) Ukuran ini dipresentasikan oleh Blanzieri and Ricci, berbeda dari SFM yaitu meminimumkan selisih antara kesalahan berhingga dan kesalahan asymtotic. MRM meminimumkan risk of misclassification yang didefinisikan dengan d(x,y)=C\u2211c=1P(c|x)(1\u2212P(c|y)) Mengukur Jarak Tipe Ordinal Nilai-nilai atribut ordinal memiliki urutan atau peringkat, namun besarnya antara nilai-nilai berturut-turut tidak diketahui. Contohnya tingkatan kecil, sedang, besar untuk atribut ukuran. Atribut ordinal juga dapat diperoleh dari diskritisasi atribut numerik dengan membuat rentang nilai ke dalam sejumlah kategori tertentu. Kategori-kategori ini disusun dalam peringkat. Yaitu, rentang atribut numerik dapat dipetakan ke atribut ordinal ff yang memiliki MfMf state. Misalnya, kisaran suhu atribut skala-skala (dalam Celcius)dapat diatur ke dalam status berikut: \u221230 hingga \u221210, \u221210 hingga 10, 10 hingga 30, masing-masing mewakili kategori suhu dingin, suhu sedang, dan suhu hangat. MM adalah jumlah keadaan yang dapat dilakukan oleh atribut ordinalmemiliki. State ini menentukan peringkat 1,...,Mf1,...,Mf Perlakuan untuk atribut ordinal adalah cukup sama dengan atribut numerik ketika menghitung disimilarity antara objek. Misalkan ff adalah atribut-atribut dari atribut ordinal dari nn objek. Menghitung disimilarity terhadap f fitur sebagai berikut: Nilai ff untuk objek ke-ii adalah xifxif, dan ff memiliki MfMf status urutan , mewakili peringkat 1,..,Mf1,..,Mf Ganti setiap xifxif dengan peringkatnya, rif\u2208{1...Mf}rif\u2208{1...Mf} Karena setiap atribut ordinal dapat memiliki jumlah state yang berbeda, diperlukan untuk memetakan rentang setiap atribut ke [0,0, 1.0] sehingga setiap atribut memiliki bobot yang sama. Perl melakukan normalisasi data dengan mengganti peringkat rifrif denganzif=rif\u22121Mf\u22121zif=rif\u22121Mf\u22121 Dissimilarity kemudian dihitung dengan menggunakan ukuran jarak seperti atribut numerik dengan data yang baru setelah ditransformasi $ z _ { i f }$ Menghitung Jarak Tipe Campuran Menghitung ketidaksamaan antara objek dengan atribut campuran yang berupa nominal, biner simetris, biner asimetris, numerik, atau ordinal yang ada pada kebanyakan databasae dapat dinyatakan dengan memproses semua tipe atribut secara bersamaan. Salah satu teknik tersebut menggabungkan atribut yang berbeda ke dalam matriks ketidaksamaan tunggal dan menyatakannya dengan skala interval antar [0,0,1.0][0,0,1.0]. Misalkan data berisi atribut pp tipe campuran. Ketidaksamaan (disimilarity ) antara objek ii dan jj dinyatakan dengan d(i,j)=\u2211pf=1\u03b4(f)ijd(f)ij\u2211pf=1\u03b4(f)ijd(i,j)=\u2211f=1p\u03b4ij(f)dij(f)\u2211f=1p\u03b4ij(f) dimana \u03b4fij=0\u03b4ijf=0 - jika xifxif atau xjfxjf adalah hilang (i.e., tidak ada pengukuran dari atribut f untuk objek ii atau objek jj) jika xif=xjf=0xif=xjf=0 dan atribut ff adalah binary asymmetric, selain itu \u03b4fij=1\u03b4ijf=1 Kontribusi dari atribut ff untuk dissimilarity antara i dan j (yaitu.dfijdijf) dihitung bergantung pada tipenya, Jika ff adalah numerik, dfij=\u2225xif\u2212xjf\u2225maxhxhf\u2212minhxhfdijf=\u2016xif\u2212xjf\u2016maxhxhf\u2212minhxhf, di mana h menjalankan semua nilai objek yang tidak hilang untuk atribut f Jika ff adalah nominal atau binary,$d_{ij}^{f}=0 $jika xif=xjfxif=xjf, sebaliknya dfij=1dijf=1 Jika ff adalah ordinal maka hitung rangking rifrif dan zif=rif\u22121Mf\u22121zif=rif\u22121Mf\u22121 , dan perlakukan zifzif sebagai numerik. ```python #contoh penerapan untuk mengukur jarak pada data import pandas as pd df = pd.read_csv('tugaspd2.csv',nrows=5) df binary=[6] num=[0,1,2,3,4,5] from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[0]+[0], [\"v1-v3\"]+[0]+[0]+[0], [\"v2-v3\"]+[0]+[0]+[0], [\"v3-v4\"]+[0]+[0]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) def chordDist(v1,v2,jnis): jmlh=0 normv1=0 normv2=0 for x in range (len(jnis)): normv1=normv1+(int(df.values.tolist()[v1][jnis[x]]) 2) normv2=normv2+(int(df.values.tolist()[v2][jnis[x]]) 2) jmlh=jmlh+(int(df.values.tolist()[v1][jnis[x]]) int(df.values.tolist()[v2][jnis[x]])) return ((2-(2 jmlh/(normv1 normv2))) *0.5) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[0], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[0], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[0], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) def binaryDist(v1,v2,jnis): q=0 r=0 s=0 t=0 for x in range (len(jnis)): if (int(df.values.tolist()[v1][jnis[x]]))==1 and (int(df.values.tolist()[v2][jnis[x]]))==1: q=q+1 elif (int(df.values.tolist()[v1][jnis[x]]))==1 and (int(df.values.tolist()[v2][jnis[x]]))==2: r=r+1 elif (int(df.values.tolist()[v1][jnis[x]]))==2 and (int(df.values.tolist()[v2][jnis[x]]))==1: s=s+1 else: t=t+1 return ((r+s)/(q+r+s+t)) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[binaryDist(0,1,binary)], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[binaryDist(0,2,binary)], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[binaryDist(1,2,binary)], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[binaryDist(2,3,binary)], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) ```","title":"Home"},{"location":"#mengukur-jarak-atribut-binary","text":"","title":"Mengukur Jarak Atribut Binary"},{"location":"#mengukur-jarak-tipe-categorical","text":"","title":"Mengukur Jarak Tipe categorical"},{"location":"#overlay-metric","text":"Ketika semua atribut adalah bertipe nominal, ukuran jarak yang paling sederhana adalah dengan Ovelay Metric (OM) yang dinyatakan dengan d(x,y)=n\u2211i=1\u03b4(ai(x),ai(y))d(x,y)=\u2211i=1n\u03b4(ai(x),ai(y)) dimana nn adalah banyaknya atribut, ai(x)ai(x) dan ai(y)ai(y) adalah nilai atribut ke ii yaitu AiAi dari masing masing objek xx dan yy, \u03b4 (ai(x),ai(y))\u03b4 (ai(x),ai(y)) adalah 0 jika ai(x)=ai(y)ai(x)=ai(y) dan 1 jika sebaliknya. OM banyak digunakan oleh instance-based learning dan locally weighted learning. Jelas sekali , ini sedikit beruk untuk mengukur jarak antara masing-masing pasangan sample, karena gagal memanfaatkan tambahan informasi yang diberikan oleh nilai atribut nominal yang bisa membantu dalam generalisasi.","title":"Overlay Metric"},{"location":"#value-difference-metric-vdm","text":"VDM dikenalkan oleh Standfill and Waltz, versi sederhana dari VDM tanpa skema pembobotan didefinsisikan dengan d(x,y)=n\u2211i=1C\u2211c=1|P(c|ai(x))\u2212P(c|ai(y))|d(x,y)=\u2211i=1n\u2211c=1C|P(c|ai(x))\u2212P(c|ai(y))| dimana CCadalah banyaknya kelas, P(c|ai(x))P(c|ai(x)) adalah probabilitas bersyarat dimana kelas xx adalah cc dari atribut AiAi, yang memiliki nilai ai(x)ai(x), P(c|ai(y))P(c|ai(y)) adalah probabilitas bersyarat dimana kelas yy adalah cc dengan atribut AiAi memiliki nilai ai(y)ai(y) VDM mengasumsikan bahwa dua nilai dari atribut adalah lebih dekat jika memiliki klasifikasi sama. Pendekatan lain berbasi probabilitas adalah SFM (Short and Fukunaga Metric) yang kemudian dikembangkan oleh Myles dan Hand dan didefinisikan dengan d(x,y)=C\u2211c=1|P(c|x)\u2212P(c|y)|d(x,y)=\u2211c=1C|P(c|x)\u2212P(c|y)| diman probabilitas keanggotaan kelas diestimasi dengan P(c|x)P(c|x) dan P(c|y)P(c|y) didekati dengan Naive Bayes,","title":"Value Difference Metric (VDM)"},{"location":"#minimum-risk-metric-mrm","text":"Ukuran ini dipresentasikan oleh Blanzieri and Ricci, berbeda dari SFM yaitu meminimumkan selisih antara kesalahan berhingga dan kesalahan asymtotic. MRM meminimumkan risk of misclassification yang didefinisikan dengan d(x,y)=C\u2211c=1P(c|x)(1\u2212P(c|y))","title":"Minimum Risk Metric (MRM)"},{"location":"#mengukur-jarak-tipe-ordinal","text":"Nilai-nilai atribut ordinal memiliki urutan atau peringkat, namun besarnya antara nilai-nilai berturut-turut tidak diketahui. Contohnya tingkatan kecil, sedang, besar untuk atribut ukuran. Atribut ordinal juga dapat diperoleh dari diskritisasi atribut numerik dengan membuat rentang nilai ke dalam sejumlah kategori tertentu. Kategori-kategori ini disusun dalam peringkat. Yaitu, rentang atribut numerik dapat dipetakan ke atribut ordinal ff yang memiliki MfMf state. Misalnya, kisaran suhu atribut skala-skala (dalam Celcius)dapat diatur ke dalam status berikut: \u221230 hingga \u221210, \u221210 hingga 10, 10 hingga 30, masing-masing mewakili kategori suhu dingin, suhu sedang, dan suhu hangat. MM adalah jumlah keadaan yang dapat dilakukan oleh atribut ordinalmemiliki. State ini menentukan peringkat 1,...,Mf1,...,Mf Perlakuan untuk atribut ordinal adalah cukup sama dengan atribut numerik ketika menghitung disimilarity antara objek. Misalkan ff adalah atribut-atribut dari atribut ordinal dari nn objek. Menghitung disimilarity terhadap f fitur sebagai berikut: Nilai ff untuk objek ke-ii adalah xifxif, dan ff memiliki MfMf status urutan , mewakili peringkat 1,..,Mf1,..,Mf Ganti setiap xifxif dengan peringkatnya, rif\u2208{1...Mf}rif\u2208{1...Mf} Karena setiap atribut ordinal dapat memiliki jumlah state yang berbeda, diperlukan untuk memetakan rentang setiap atribut ke [0,0, 1.0] sehingga setiap atribut memiliki bobot yang sama. Perl melakukan normalisasi data dengan mengganti peringkat rifrif denganzif=rif\u22121Mf\u22121zif=rif\u22121Mf\u22121 Dissimilarity kemudian dihitung dengan menggunakan ukuran jarak seperti atribut numerik dengan data yang baru setelah ditransformasi $ z _ { i f }$","title":"Mengukur Jarak Tipe Ordinal"},{"location":"#menghitung-jarak-tipe-campuran","text":"Menghitung ketidaksamaan antara objek dengan atribut campuran yang berupa nominal, biner simetris, biner asimetris, numerik, atau ordinal yang ada pada kebanyakan databasae dapat dinyatakan dengan memproses semua tipe atribut secara bersamaan. Salah satu teknik tersebut menggabungkan atribut yang berbeda ke dalam matriks ketidaksamaan tunggal dan menyatakannya dengan skala interval antar [0,0,1.0][0,0,1.0]. Misalkan data berisi atribut pp tipe campuran. Ketidaksamaan (disimilarity ) antara objek ii dan jj dinyatakan dengan d(i,j)=\u2211pf=1\u03b4(f)ijd(f)ij\u2211pf=1\u03b4(f)ijd(i,j)=\u2211f=1p\u03b4ij(f)dij(f)\u2211f=1p\u03b4ij(f) dimana \u03b4fij=0\u03b4ijf=0 - jika xifxif atau xjfxjf adalah hilang (i.e., tidak ada pengukuran dari atribut f untuk objek ii atau objek jj) jika xif=xjf=0xif=xjf=0 dan atribut ff adalah binary asymmetric, selain itu \u03b4fij=1\u03b4ijf=1 Kontribusi dari atribut ff untuk dissimilarity antara i dan j (yaitu.dfijdijf) dihitung bergantung pada tipenya, Jika ff adalah numerik, dfij=\u2225xif\u2212xjf\u2225maxhxhf\u2212minhxhfdijf=\u2016xif\u2212xjf\u2016maxhxhf\u2212minhxhf, di mana h menjalankan semua nilai objek yang tidak hilang untuk atribut f Jika ff adalah nominal atau binary,$d_{ij}^{f}=0 $jika xif=xjfxif=xjf, sebaliknya dfij=1dijf=1 Jika ff adalah ordinal maka hitung rangking rifrif dan zif=rif\u22121Mf\u22121zif=rif\u22121Mf\u22121 , dan perlakukan zifzif sebagai numerik. ```python #contoh penerapan untuk mengukur jarak pada data import pandas as pd df = pd.read_csv('tugaspd2.csv',nrows=5) df binary=[6] num=[0,1,2,3,4,5] from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[0]+[0], [\"v1-v3\"]+[0]+[0]+[0], [\"v2-v3\"]+[0]+[0]+[0], [\"v3-v4\"]+[0]+[0]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) def chordDist(v1,v2,jnis): jmlh=0 normv1=0 normv2=0 for x in range (len(jnis)): normv1=normv1+(int(df.values.tolist()[v1][jnis[x]]) 2) normv2=normv2+(int(df.values.tolist()[v2][jnis[x]]) 2) jmlh=jmlh+(int(df.values.tolist()[v1][jnis[x]]) int(df.values.tolist()[v2][jnis[x]])) return ((2-(2 jmlh/(normv1 normv2))) *0.5) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[0], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[0], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[0], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) def binaryDist(v1,v2,jnis): q=0 r=0 s=0 t=0 for x in range (len(jnis)): if (int(df.values.tolist()[v1][jnis[x]]))==1 and (int(df.values.tolist()[v2][jnis[x]]))==1: q=q+1 elif (int(df.values.tolist()[v1][jnis[x]]))==1 and (int(df.values.tolist()[v2][jnis[x]]))==2: r=r+1 elif (int(df.values.tolist()[v1][jnis[x]]))==2 and (int(df.values.tolist()[v2][jnis[x]]))==1: s=s+1 else: t=t+1 return ((r+s)/(q+r+s+t)) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[binaryDist(0,1,binary)], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[binaryDist(0,2,binary)], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[binaryDist(1,2,binary)], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[binaryDist(2,3,binary)], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) ```","title":"Menghitung Jarak Tipe Campuran"}]}